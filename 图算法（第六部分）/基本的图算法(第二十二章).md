# 基本的图算法

## 图的表示

图的表示有两种方法：

1. 邻接矩阵（一般用二维数组实现）
2. 邻接表（一般用链式前向星实现）

这两种方式在算法题中可以视数据大小实现，数据量大用邻接表，数据量小的话可以直接使用邻接矩阵，更加方便。

**邻接矩阵**：$g[a][b]$表示从$a$到$b$的边

**链式前向星**：

```c++
// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;

// 添加一条边a->b
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);
```

---

## 广度优先搜索

最简单的搜索算法之一：使用队列进行维护

从一个节点开始，遍历它本身与它的子节点；接着再遍历子节点的子节点。

时间复杂度：$O(n)$（其中$n$为总状态数，也是总节点数）

---

## 深度优先搜索

和广度优先搜索一样，都是最简单的搜索算法之一：使用栈进行维护（当然可以递归调用，省去栈的使用）

相当于使用递归栈来维护。

从一个节点开始，接着往深度开始遍历，一个接着一个节点遍历，直到遍历完成，回溯到上一个节点。

时间复杂度：$O(b^m)$（其中$b$为最大分支因子，$m$为最大深度）

在图中，这个时间复杂度为：$\Theta(|V|+|E|)$

---

## 拓扑排序

本质是从一个集合上的偏序得到一个全序。

逐步删除每个入度为$0$的节点，存入队列中。

必须是有向无环图才有拓扑排序。

时间复杂度：$O(|V|+|E|)$

```c++
bool topsort(void) {
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt) {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
```

---

## 强连通分量

参考：[强连通分量 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/scc/)

定义（人话版）：一个有向图的子图，这个子图中所有顶点相互可达，则这个子图（应该为极大的）被称为强连通分量。

算法导论中介绍的是Kosaraju算法

该算法依靠两次简单的 DFS 实现：

第一次 DFS，选取任意顶点作为起点，遍历所有未访问过的顶点，并在回溯之前给顶点编号，也就是后序遍历。

第二次 DFS，对于反向后的图，以标号最大的顶点作为起点开始 DFS。这样遍历到的顶点集合就是一个强连通分量。对于所有未访问过的结点，选取标号最大的，重复上述过程。

两次 DFS 结束后，强连通分量就找出来了，Kosaraju 算法的时间复杂度为：$O(|V|+|E|)$

```c++
// g 是原图，g2 是反图

void dfs1(int u) {
  vis[u] = true;
  for (int v : g[u])
    if (!vis[v]) dfs1(v);
  s.push_back(u);
}

void dfs2(int u) {
  color[u] = sccCnt;
  for (int v : g2[u])
    if (!color[v]) dfs2(v);
}

void kosaraju() {
  sccCnt = 0;
  for (int i = 1; i <= n; ++i)
    if (!vis[i]) dfs1(i);
  for (int i = n; i >= 1; --i)
    if (!color[s[i]]) {
      ++sccCnt;
      dfs2(s[i]);
    }
}
```

