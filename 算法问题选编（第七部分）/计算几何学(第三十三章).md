# 计算几何学

本章内容数学含量较多，也可以参考：[计算几何部分简介 - OI Wiki (oi-wiki.org)](https://oi-wiki.org//geometry/)

叉乘（又称叉积）是计算线段方法的核心。当叉积等于$0$时，两个向量是共线的。也可以用叉积求两个向量形成的平行四边形的面积。

## 凸包

点集$Q$的凸包是一个最小的凸多边形$P$，满足$Q$中的每个点都在$P$的边界或者内部，我们用$CH(Q)$来表示$Q$的凸包。

$Andrew$算法（在《算法导论》中称之为$Graham$扫描法）求凸包：

算法的时间复杂度为：$O(nlogn)$

原理是对点集按照横纵坐标排序后，使用单调栈维护以下内容：

1. 最前与最后两点一定是凸包上的点
2. 由于是一个凸多边形，因此我们只需要维护每一次加上的边必须是向"左"拐的。

```c++
// stk[] 是整型，存的是下标
// p[] 存储向量或点
tp = 0;                       // 初始化栈
std::sort(p + 1, p + 1 + n);  // 对点进行排序
stk[++tp] = 1;
// 栈内添加第一个元素，且不更新 used，使得 1 在最后封闭凸包时也对单调栈更新
for (int i = 2; i <= n; ++i) {
  while (tp >= 2  // 下一行 * 操作符被重载为叉积
        && (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0)
    used[stk[tp--]] = 0;
  used[i] = 1;  // used 表示在凸壳上
  stk[++tp] = i;
}
int tmp = tp;  // tmp 表示下凸壳大小
for (int i = n - 1; i > 0; --i)
  if (!used[i]) {
    // ↓求上凸壳时不影响下凸壳
    while (tp > tmp && (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0)
      used[stk[tp--]] = 0;
    used[i] = 1;
    stk[++tp] = i;
  }
for (int i = 1; i <= tp; ++i)  // 复制到新数组中去
  h[i] = p[stk[i]];
int ans = tp - 1;
```

